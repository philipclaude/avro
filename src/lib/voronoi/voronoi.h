// avro: Adaptive Voronoi Remesher
// Copyright 2017-2019, Massachusetts Institute of Technology
// Licensed under The GNU Lesser General Public License, version 2.1
// See http://www.opensource.org/licenses/lgpl-2.1.php

#ifndef AVRO_MESH_DELAUNAY_VORONOI_H_
#define AVRO_MESH_DELAUNAY_VORONOI_H_

#include "common/pointer.h"

#include "graph/neighbours.h"

#include "mesh/mesh.h"
#include "mesh/topology.h"
#include "mesh/types.h"

#include "numerics/predicates.h"

namespace avro
{

class Delaunay;
class RestrictedVoronoiSimplex;

namespace delaunay
{

class Vertex
{
  friend class VoronoiVertex_tester;

public:
  // constructors/destructor
  Vertex() {}
  explicit Vertex( const coord_t _dim );
  Vertex( const coord_t _dim , const coord_t _number );
  Vertex( const Vertex& v0 );
  Vertex(Vertex&& v);
  Vertex( const std::vector<real> _x , const coord_t _number=0 );
  Vertex( const real* x, const coord_t dim );

  Vertex& operator=( const Vertex& rhs) { return *this; }

  // coordinate/topology set/get functions
  void init();
  coord_t dim() const { return dim_; }
  coord_t number() const { return number_; }
  void setNumber( coord_t _number ) { number_ = _number; }
  const std::vector<real>& x() const { return x_; }
  const real* X() const { return x_.data(); }
  const real& operator[] ( const index_t d ) const { return x_[d]; }
  const real& coord( const index_t d ) const { return x_[d]; }
  void setCoordinates( const real* x , const coord_t _dim )
  {
    dim_ = _dim;
    init();
    for (coord_t d=0;d<dim_;d++)
      x_[d] = x[d];
  }

  // bisector retrieval/addition functions
  void addBisector( int b ) { bisector_.push_back(b); }
  const std::vector<int>& bisectors() const { return bisector_; }
  index_t bisector( const index_t k ) const { return bisector_[k]; }
  index_t nb_bisectors() const { return bisector_.size(); }

  // topology retrieval/addition functions
  void addTopology( Topology<Simplex>* m ) { topology_.push_back(m); }
  const std::vector< Topology<Simplex>* >& topologies() const { return topology_; }
  Topology<Simplex>* topology( const index_t k ) const { return topology_[k]; }

  // simplex retrieval/addition functions
  void addSimplexVertex( const real* v ) { simplex_.push_back(v); }
  const std::vector<const real*>& simplices() const { return simplex_; }
  index_t nb_simplices() const { return simplex_.size(); }
  const real* simplex( const index_t k ) const { return simplex_[k]; }

  // site addition function
  void addSite( const real* zj ) { site_.push_back(zj); }
  std::vector<const real*> sites() const { return site_; }
  const real* site( const index_t k ) const { return site_[k]; }
  index_t nb_sites() const { return site_.size(); }

  // intersection functions
  void intersectSymbolic( const Vertex* v0 , const Vertex* v1 ,
      const Delaunay& delaunay );
  void intersectGeometric( const real* q1 , const real* q2 , const real* p1 , const real* p2 );
  void intersectBisectors( const Vertex* v0 , const Vertex* v1 );
  void intersectMeshes( const Vertex* v0 , const Vertex* v1 );
  void intersectSimplices( const Vertex* v0 , const Vertex* v1 );
  void setSites( const Delaunay& delaunay );
  void setBaseSite( const real* z0 ) { z0_ = z0; }
  void setDelaunaySite( const index_t k , const real* z )
    { (k==0) ? z0_ = z : site_[k-1] = z; }

  // side query relative to a bisector
  GEO::Sign sideFast( const real* zi , const real *zj );
  GEO::Sign side( const real* zi , const real* zj , const bool exact = true );

  // print function
  void print( const std::string& pre , const bool symbolic=false ) const;

private:
  coord_t dim_;
  coord_t number_;
  std::vector<real>  x_;

  const real* z0_;
  std::vector<int> bisector_;
  std::vector< Topology<Simplex>* > topology_;
  std::vector<const real*> simplex_;
  std::vector<const real*> site_;
};

class RVDFacets
{
public:
  RVDFacets( const Topology<Simplex>& topology );
  RVDFacets( const Topology<Simplex>& topology , const std::vector<index_t>& S );

  void create();
  void create( const std::vector<index_t>& simplices );
  int facet( const std::vector<index_t>& f ) const;
  void print() const;

private:
  std::string generate( const std::vector<index_t>& f ) const;
  int lookup( const std::string& s , int& id ) const;

  std::map<std::string,int> store_;
  const Topology<Simplex>& topology_;

};


class RestrictedVoronoiSimplex : public Mesh<ConvexPolytope>
{
  friend class RestrictedSimplex_tester;

public:
  RestrictedVoronoiSimplex(
    const index_t k , const Topology<Simplex>& mesh , RVDFacets& facets ,
    Delaunay& _delaunay , graph::Neighbours& _neighbours , bool _exact );

  void reset();

  // clip the simplex by the entire Voronoi diagram defined by delaunay_
  void clip();

  // clip the simplex by the cell generated by seed i of the voronoi diagram
  void clip( const index_t i );

  // clip the current polytope by the bisector zi_ to neighbour_[zi][j]
  void clipPolytope( index_t j );

  // clip the edge e0-e1 by the bisector b into the clipped polytope q
  void clipEdge( const index_t e0 , const index_t e1 , const int b ,
    std::vector<index_t>& q );

  // delaunay site functions
  index_t nb_sites() const;
  void nextSite();
  index_t site() const { return site_; }
  void addSite( const index_t zj );

  bool securityRadiusReached( const real* zi , const real* zj ) const;

  // function to send the vertices into their location after merging and stuff
  void finalize();

  index_t seed( const index_t k ) const { return seed_[k]; }

  Topology<ConvexPolytope>& topology() { return topology_; }
  using Mesh<ConvexPolytope>::topology; // silences clang warning

private:
  index_t site_;
  std::vector<index_t> sites_;
  std::vector<bool>    clipped_;

  // yes, this is a vector of objects, but the invocation of the copy
  // constructor is avoided by pushing a default VoronoiVertex
  // and then populating its fields from the created one
  std::vector<Vertex> vertex_;

  std::vector<index_t> simplex_;   // original simplex vertices
  std::vector<index_t> polytope_;  // current polytope vertices

  // the delaunay neighbours for each cell in this RVS
  Data<index_t> region_;

  const RVDFacets& facets_;
  const Delaunay& delaunay_;
  const graph::Neighbours& neighbours_;
  const bool exact_;

  std::vector<index_t> seed_;

  Topology<ConvexPolytope> topology_;

};

class RestrictedVoronoiDiagram : public Mesh<ConvexPolytope>
{
public:

  typedef RestrictedVoronoiDiagram thisclass;

  RestrictedVoronoiDiagram( const Topology<Simplex>& _mesh , Delaunay& _delaunay );
  RestrictedVoronoiDiagram( Delaunay& _delaunay );

  void compute( const bool exact = true );
  void compute( const std::vector<index_t>& S , const bool exact = true );

  void accumulate();

  index_t nb_simplices() const { return simplices_.size(); }
  RestrictedVoronoiSimplex* simplex( const index_t k ) const
    { return smart_raw(simplices_[k]); }

  void computeCentroids( Vertices& centroids );

  real energy();
  real energy() const { return energy_; }

  real energy_nd();

  bool& parallel() { return parallel_; }
  bool& gpu() { return gpu_; }

  void optimise( const index_t nb_iter , bool exact=false , FILE* fid=NULL );

  std::string& outdir() { return outdir_; }

  void clip( const index_t k )
    { simplices_[k]->clip(); }

  void extract( Topology<Simplex>& triangulation ) const;

private:

  const Topology<Simplex>& mesh_;
  Delaunay& delaunay_;
  graph::Neighbours neighbours_;

  std::vector<smart_ptr(RestrictedVoronoiSimplex)> simplices_;

  bool parallel_;
  bool gpu_;
  real energy_;
  std::string outdir_;

  class VoronoiSites : public CellField<real>
  {
  public:
    VoronoiSites() {}

    void addCell( const real z )
    {
      Field<real>::add(z+1);
    }

    index_t rank() const { return 1; }
    std::vector<std::string> ranknames() const
     {std::vector<std::string> result; result.push_back("sites"); return result;}
  };

  VoronoiSites sites_;

};

} // delaunay

} // avro

#endif
